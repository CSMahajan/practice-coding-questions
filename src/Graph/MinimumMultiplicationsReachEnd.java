package Graph;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

/*
Minimum Multiplications to reach End

Given start, end and an array arr of n numbers. At each step, start is multiplied with any number in the array and
then mod operation with 100000 is done to get the new start.
Your task is to find the minimum steps in which end can be achieved starting from start.
If it is not possible to reach end, then return -1.
Example 1:
Input:
arr[] = {2, 5, 7}
start = 3, end = 30
Output:
2
Explanation:
Step 1: 3*2 = 6 % 100000 = 6
Step 2: 6*5 = 30 % 100000 = 30
Example 2:
Input:
arr[] = {3, 4, 65}
start = 7, end = 66175
Output:
4
Explanation:
Step 1: 7*3 = 21 % 100000 = 21
Step 2: 21*3 = 63 % 100000 = 63
Step 3: 63*65 = 4095 % 100000 = 4095
Step 4: 4095*65 = 266175 % 100000 = 66175
*/
public class MinimumMultiplicationsReachEnd {

    //Time Complexity : O(100000 * N)
    //Where '100000' are the total possible numbers generated by multiplication (hypothetical) and
    //N = size of the array with numbers of which each node could be multiplied.
    //Space Complexity :  O(100000 * N)
    //Where '100000' are the total possible numbers generated by multiplication (hypothetical) and
    //N = size of the array with numbers of which each node could be multiplied.
    //100000 * N is the max possible queue size. The space complexity of the dist array is constant.
    public int minimumMultiplications(int[] arr, int start, int end) {
        // Your code here
        Queue<Pair> queue = new LinkedList<>();
        queue.add(new Pair(start, 0));
        //We required an array of size 100000 because we need to take the mod 100000, so the values would vary from 0 to 99999
        //multiplicationSteps array denotes the number of steps required to reach the number
        int[] multiplicationSteps = new int[100000];
        Arrays.fill(multiplicationSteps, (int) 1e9);
        multiplicationSteps[start] = 0;
        int mod = 100000;
        int n = arr.length;
        // O(100000 * N)
        //Multiply the start no. with each of numbers in the arr until we get the end no.
        //basically we perform Dijkstra's BFS traversal
        //We get the number and steps from the queue and for each number in the given array if we can reach the end(or target number)
        //and update the steps to minimum possible (i.e.1+steps{steps to reach previous or popped number from the queue)
        while (!queue.isEmpty()) {
            int number = queue.peek().number;
            int steps = queue.peek().steps;
            queue.remove();
            for (int i = 0; i < n; i++) {
                int newNumber = (arr[i] * number) % mod;
                if (multiplicationSteps[newNumber] > 1 + steps) {
                    //updating value of multiplicationSteps[newNumber] is required before return or adding it to the queue
                    multiplicationSteps[newNumber] = 1 + steps;
                    if (newNumber == end) {
                        return multiplicationSteps[newNumber];
                    }
                    queue.add(new Pair(newNumber, multiplicationSteps[newNumber]));
                }
            }
        }
        return -1;
    }

    static class Pair {
        int number;
        int steps;

        public Pair(int number, int steps) {
            this.number = number;
            this.steps = steps;
        }
    }

    public static void main(String[] args) {
        int[] arr = {3, 4, 65};
        int start = 7, end = 66175;
        MinimumMultiplicationsReachEnd mmre = new MinimumMultiplicationsReachEnd();
        System.out.println(mmre.minimumMultiplications(arr,start,end));
    }
}
